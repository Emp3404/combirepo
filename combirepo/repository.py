#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
import os
import shutil
import logging
import glob
import hidden_subprocess
import temporaries
import files
import check


class RepositoryData():
    """
    The repository data that is not automatically generated by createrepo but
    is the additinal property of the repository
    (i. e. the content of group.xml and patterns.xml files).
    """
    def __init__(self):
        """
        Initializes the repository data (does nothing).
        """
        self.groups_data = None
        self.patterns_data = None

    def find_in_directory(self, directory_path):
        """
        Tries to find group.xml and patterns.xml files in the given directory
        and reads them in.

        @param directory_path    The search directory.
        """
        all_groups = files.find_fast(directory_path, ".*group\.xml$")
        all_groups_gzipped = files.find_fast(directory_path,
                                             ".*group\.xml\.gz$")
        for path in all_groups_gzipped:
            hidden_subprocess.silent_call(["gzip", "-d", "-k", "-f", path])
            all_groups.append(path.replace(".gz", ""))

        all_patterns = files.find_fast(directory_path, ".*patterns\.xml$")
        all_patterns_gzipped = files.find_fast(directory_path,
                                               ".*patterns\.xml\.gz$")
        for path in all_patterns_gzipped:
            hidden_subprocess.silent_call(["gzip", "-d", "-k", "-f", path])
            all_patterns.append(path.replace(".gz", ""))

        groups = None
        if len(all_groups) > 1:
            logging.warning("Multiple groups XML files found:")
            for file_path in all_groups:
                logging.warning(" * {0}".format(file_path))
            groups = all_groups[0]
            logging.warning("Selecting {0}".format(groups))
        elif len(all_groups) == 1:
            groups = all_groups[0]

        patterns = None
        if len(all_patterns) > 1:
            logging.warning("Multiple patterns XML files found:")
            for file_path in all_patterns:
                logging.warning(" * {0}".format(file_path))
            patterns = all_patterns[0]
            logging.warning("Selecting {0}".format(patterns))
        elif len(all_patterns) == 1:
            patterns = all_patterns[0]

        if groups is not None:
            with open(groups, "r") as groups_file:
                self.groups_data = groups_file.readlines()
        if patterns is not None:
            with open(patterns, "r") as patterns_file:
                self.patterns_data = patterns_file.readlines()

    def find_in_repository(self, repository_path):
        """
        Searches for group.xml and patterns.xml in the package-groups-*.rpm
        package in the given repository (if exists) and returns them.

        @param repository_path  The path to the repository.
        """
        package_groups_package = None

        package_groups_packages = files.find_fast(repository_path,
                                                  "^package-groups.*\.rpm$")
        if len(package_groups_packages) > 1:
            logging.warning("Multiple package-groups RPMs found:")
            for package in package_groups_packages:
                logging.warning(" * {0}".format(package))
            package_groups_package = package_groups_packages[0]
            logging.warning("Selecting {0}".format(package_groups_package))
        elif len(package_groups_packages) == 1:
            package_groups_package = package_groups_packages[0]
        if package_groups_package is None:
            return None, None

        package_groups_package = os.path.abspath(package_groups_package)
        directory_unpacking = temporaries.create_temporary_directory("groups")
        initial_directory = os.getcwd()
        files.unrpm(package_groups_package, directory_unpacking)
        self.find_in_directory(directory_unpacking)


class Repository(object):
    """
    Repository handle that is used to generate standard repodata in different
    situations.
    """
    def __init__(self, path=None):
        """
        Initializes the repository (does nothing).
        """
        self._path = path
        self.data = RepositoryData()

    @property
    def path(self):
        """The path to the repository."""

    @path.setter
    def path(self, value):
        check.directory_exists(value)
        self._path = value

    @path.deleter
    def path(self):
        del self._path

    def prepare_data(self):
        """
        Prepares the data into the run-time object that can be used by other
        parts of program.
        """
        repodata_path = os.path.join(self._path, "repodata")

        if not os.path.isdir(repodata_path):
            logging.warning("There is no repodata directory in repository "
                            "{0}".format(repodata_path))
        else:
            self.data.find_in_directory(repodata_path)

            if (self.data.groups_data is None or
                    self.data.patterns_data is None):
                self.data.find_in_directory(self._path)

            if (self.data.groups_data is None or
                    self.data.patterns_data is None):
                self.data.find_in_repository(self._path)

    def set_data(self, data):
        """
        Sets the repository data.

        @param data The data to be set.
        """
        self.data = data

    def get_data(self):
        """
        Gets the repository data.

        @return     The repository data.
        """
        self.prepare_data
        return self.data

    def __workaround_repodata_open_checksum_bug(self):
        """
        Workarounds some bug in repodata creation.

        This is a workaround for the case when tag <open-checksum> for
        group.xml is not created in repomd.xml file.

        Nota Bene: This somehow reproduces the standard Tizen repodata
        creation. If you see repodata on release servers, group.xml in them
        is not registered in repomd.xml file, but *.group.xml.gz file is
        registered in it.

        Without this workaround mic will fail during the repodata parsing.
        """
        initial_directory = os.getcwd()
        repodata_path = os.path.join(self._path, "repodata")
        os.chdir(repodata_path)
        backup_group_files = []
        for group_file in glob.glob("*group.xml"):
            backup_group_file = temporaries.create_temporary_file("group.xml")
            shutil.copy(group_file, backup_group_file)
            backup_group_files.append((group_file, backup_group_file))
            modifyrepo_command = ["modifyrepo", "--remove", group_file,
                                  repodata_path]
            exit_value = hidden_subprocess.silent_call(modifyrepo_command)
            if exit_value != 0:
                raise Exception("modifyrepo failed with exit value = "
                                "{0}".format(exit_value))

        # Restore backuped group files, but they will not be registered in
        # repomd.xml file anymore.
        for backup_group_file in backup_group_files:
            shutil.copy(backup_group_file[1], backup_group_file[0])

        os.chdir(initial_directory)

    def generate_derived_data(self):
        """
        Generates the automatically generated data of the repository.
        """
        self._path = os.path.abspath(self._path)
        initial_directory = os.getcwd()
        os.chdir(self._path)

        repodata_path = os.path.join(self._path, "repodata")
        if os.path.isdir(repodata_path):
            logging.warning("The repository data already exists in "
                            "{0}! It will be removed and "
                            "re-generated".format(repodata_path))
            shutil.rmtree(repodata_path)
            os.mkdir(repodata_path)
        else:
            os.mkdir(repodata_path)

        createrepo_command = ["createrepo", self._path, "--database",
                              "--unique-md-filenames"]
        if self.data.groups_data is not None:
            groups_file_path = os.path.join(repodata_path, "group.xml")
            with open(groups_file_path, "w") as groups_file:
                groups_file.writelines(self.data.groups_data)
            createrepo_command.extend(["-g", "repodata/group.xml"])

        exit_value = hidden_subprocess.call("Creating repository.",
                                            createrepo_command)
        if exit_value != 0:
            raise Exception("createrepo failed with exit value = "
                            "{0}".format(exit_value))

        if self.data.patterns_data is not None:
            patterns_file_path = os.path.join(repodata_path, "patterns.xml")
            with open(patterns_file_path, "w") as patterns_file:
                patterns_file.writelines(self.data.patterns_data)
            exit_value = hidden_subprocess.silent_call(["modifyrepo",
                                                        patterns_file_path,
                                                        repodata_path])
            if exit_value != 0:
                raise Exception("modifyrepo failed with exit value = "
                                "{0}".format(exit_value))

        self.__workaround_repodata_open_checksum_bug()
        os.chdir(initial_directory)
